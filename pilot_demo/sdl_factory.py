
'''This module is to generate a valid set of machines, operations, and jobs for the pilot demo
All operations and machines are not real, and they should only be used for demo purposes.
The goal is to use these machines and jobs to show the capabilities of the scheduler,
and compare the performance of different scheduling algorithms.
'''
from pilot_demo.lab import Machine, Operation, Job
from typing import List
import numpy as np

class MachineInvalidConfiguration(Exception):
    def __init__(self, message: str):
        self.message = message
        super().__init__(self.message)

class MachineFactory:
    '''Factory class for creating Machine objects
    We ensure each operation can be done by at least one machine.
    This is done by creating a partition of operations and assign each partition to a machine.
    There can be more machines than partitions, in which case, the additional machines can be used for any random operations.
    '''
    def __init__(self):
        self.rs = np.random.RandomState(101)
        self.machines = []

    def create_machine(self, machine_id: int, machine_name: str, operations: List[Operation]) -> Machine:
        return Machine(machine_id, machine_name, operations)
    
    def create_machine_partition(self, operations: List[Operation], p :int, m : int):
        if p > m:
            raise MachineInvalidConfiguration('Total number of machines should be larger than partition number')
        if p > len(operations):
            raise MachineInvalidConfiguration('Number of partition should be smaller than total number of operations')

        splited_operations = np.array_split(operations, p)
        self.machines = []
        for id, operation_set in enumerate(splited_operations):
            self.machines.append(self.create_machine(id+1, f'M_{id+1}', set(operation_set)))
        
        remaining_machines = m - p
        for i in range(0, remaining_machines, 1):
            n_operations = self.rs.randint(1, len(operations) // 2)
            cur_operations = self.rs.choice(operations, n_operations, replace=False)
            self.machines.append(self.create_machine(p+1+i, f'M_{p+1+i}', set(cur_operations)))
        return self.machines
    

class OperationFactory:
    '''Factory class for creating Operation objects
    Each operation has an operation id, operation name and duration
    The operation names are generated by ChatGPT. The duration is randomly generated.
    '''
    def __init__(self):
        self.rs = np.random.RandomState(42)
        self.operations = []

    def create_operation(self, operation_id: int, operation_name: str, duration: int) -> Operation:
        return Operation(operation_id, operation_name, duration)
    
    def create_operation_set(self, filename='operations.txt') -> List[Operation]:
        try:
            with open(filename, 'r') as f:
                operations = f.readlines()
            # operations = [op.strip() for op in operations]
        except IOError as e:
            print(f'Cannot open file {filename}')
            print(e)
            return []
        self.operations = []
        for id, name in enumerate(operations):
            duration = self.rs.randint(5, 50)
            self.operations.append(self.create_operation(id+1, name.strip(), duration))
            # print(self.operations)
        return self.operations
        # return [self.create_operation(op_id, op_name) for op_id, op_name in operation_set]

    def choose_n_operations(self, n: int) -> List[Operation]:
        return self.rs.choice(self.operations, n, replace=False)


class JobFactory:
    '''Factory class for creating Job objects
    Each job has a job id, job name and a list of operations
    The operations are randomly selected from the operation set.
    '''
    def __init__(self):
        self.rs = np.random.RandomState(105)
        self.jobs = []

    def create_job(self, job_id: int, job_name: str, operations: List[Operation]) -> Job:
        return Job(job_id, job_name, operations)
    
    def create_job_set(self, operations: List[Operation], n: int, steps_min: int = 5, steps_max: int = 10) -> List[Job]:
        self.jobs = []
        for id in range(0, n, 1):
            n_operations = self.rs.randint(steps_min, steps_max)
            cur_operations = self.rs.choice(operations, n_operations, replace=False)
            self.jobs.append(self.create_job(id+1, f'J_{id+1}', list(cur_operations)))
        return self.jobs

class SDLFactory:
    def __init__(self):
        pass

    def create_sdl(self, p:int, m: int, n: int, o:int, steps_min: int, steps_max: int, filename='operations.txt'):
        '''Create o operations, p partitions, m machines, and n jobs.
        Example: o = 10, p = 4, m = 6, n = 5
        operations = [o1, o2, o3, o4, o5, o6, o7, o8, o9, o10]
        p = 4 means separate the above operations set into 4 partitions
        And the first 4 machines will ensure each operation can be done on at least one machine
        M1-M4: [o1, o4, o7], [o2, o8], [o3, o9], [o5, o6, o10]
        m = 6 means we need 2 more machines that can do some operations
        M5 = [o1, o5, o8, o9]
        M6 = [o4, o5, o7, o8]
        These additional machines will influence the schedule and they can possibly reduce the total makespan.
        Each job can have step_min to step_max operations
        '''
        op_fac = OperationFactory()
        op_fac.create_operation_set(filename=filename)
        operations = list(op_fac.choose_n_operations(o))
        mc_fac = MachineFactory()
        machines = mc_fac.create_machine_partition(operations=operations, p=p, m=m)
        job_fac = JobFactory()
        jobs = job_fac.create_job_set(operations=operations, n=n, steps_min=steps_min, steps_max=steps_max)
        return machines, jobs, operations

if __name__ == '__main__':
    machines, jobs, operations = SDLFactory().create_sdl(p=5, m=8, n=10, o=20, steps_min=5, steps_max=10)
    print("Machines:")
    for machine in machines:
        print(machine)
    print("Jobs:")
    for job in jobs:
        print(job)
    print("Operations:")
    for operation in operations:
        print(operation)